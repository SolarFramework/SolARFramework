/**
 * @copyright Copyright (c) 2017 B-com http://www.b-com.com/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SOLAR_IDENTIFICATION_H
#define SOLAR_IDENTIFICATION_H

#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <boost/lexical_cast.hpp>
#include "datastructure/MathDefinitions.h"
#include "datastructure/GeometryDefinitions.h"
#include "core/Log.h"
#include <iostream>
#include <string>
#include <chrono>
#include <mutex>

namespace SolAR {
namespace datastructure {

/**
	* @class Identification component
	* @brief <B>This component includes identification informations specified a map.</B>
	*/
class Identification
{
public:
	///
	/// @brief Identification constructor
	///
	Identification() {
		m_uuid = boost::uuids::nil_uuid();
		m_name = "";
		m_author = "";
		m_createdTime = std::chrono::system_clock::now();
		m_lastUpdatedTime = m_createdTime;
		m_bbox.corner = Point3Df();
		m_bbox.width = 0.f; m_bbox.height = 0.f; m_bbox.depth = 0.f;
	};

	///
	/// @brief ~Identification
	///
	~Identification() = default;

	/// 
	/// @brief Set UUID of map
	/// @param[in] uuid: the uuid. It can be generated by using boost::uuids::random_generator()()
	/// 
	bool setUUID(boost::uuids::uuid uuid) {
		if (!m_uuid.is_nil()) {
			LOG_WARNING("The UUID has actually been set");
			return false;
		}
		std::unique_lock<std::mutex> lock(m_mutex);
		m_uuid = uuid;
		return true;
	}

	/// 
	/// @brief Set UUID of map
	/// @param[in] uuid: the string uuid
	/// 
	bool setUUID(std::string uuid) {
		if (!m_uuid.is_nil()) {
			LOG_WARNING("The UUID has actually been set");
			return false;
		}
		std::unique_lock<std::mutex> lock(m_mutex);
		try
		{
			m_uuid = boost::lexical_cast<boost::uuids::uuid>(uuid);
		}
		catch (boost::bad_lexical_cast &e)
		{
			LOG_WARNING("{}",e.what());
		}
	}

	/// 
	/// @brief Get UUID of map
	/// @return the uuid 
	/// 
	void getUUID(boost::uuids::uuid &uuid) {
		std::unique_lock<std::mutex> lock(m_mutex);
		uuid = m_uuid;
	}

	/// 
	/// @brief Get UUID of map
	/// @return the uuid string
	/// 
	void getUUID(std::string &uuid) {
		std::unique_lock<std::mutex> lock(m_mutex);
		uuid = boost::lexical_cast<std::string>(m_uuid);
	}

	/// 
	/// @brief Set name of map
	/// @param[in] name: the name
	/// 
	void setName(std::string name) {
		std::unique_lock<std::mutex> lock(m_mutex);
		m_name = name;
	}

	/// 
	/// @brief Get name of map
	/// @return the name of map
	/// 
	std::string getName() {
		std::unique_lock<std::mutex> lock(m_mutex);
		return m_name;
	}

	/// 
	/// @brief Set author of map
	/// @param[in] author: the author name
	/// 
	void setAuthor(std::string author) {
		std::unique_lock<std::mutex> lock(m_mutex);
		m_author = author;
	}

	/// 
	/// @brief Get author of map
	/// @return the author of map
	/// 
	std::string getAuthor() {
		std::unique_lock<std::mutex> lock(m_mutex);
		return m_author;
	}

	///
	/// @brief This method returns the last updated time of the primitive element
	/// @return the last updated time
	///
	std::chrono::system_clock::time_point getCreatedTime() {
		std::unique_lock<std::mutex> lock(m_mutex);
		return m_createdTime;
	}

	///
	/// @brief This method updates the last updated time of the primitive element
	/// @param[in] updateTime: the update time. You can get current time by using std::chrono::system_clock::now()
	///
	void setCreatedTime(std::chrono::system_clock::time_point createdTime) {
		std::unique_lock<std::mutex> lock(m_mutex);
		m_createdTime = createdTime;
	}

	///
	/// @brief This method returns the last updated time of the primitive element
	/// @return the last updated time
	///
	std::chrono::system_clock::time_point getLastUpdateTime() {
		std::unique_lock<std::mutex> lock(m_mutex);
		return m_lastUpdatedTime;
	}

	///
	/// @brief This method updates the last updated time of the primitive element
	/// @param[in] updateTime: the update time. You can get current time by using std::chrono::system_clock::now()
	///
	void setLastUpdateTime(std::chrono::system_clock::time_point updateTime) {
		std::unique_lock<std::mutex> lock(m_mutex);
		m_lastUpdatedTime = updateTime;
	}

	/// 
	/// @brief Set 3D bounding box of map
	/// @param[in] bbox: the bounding box
	/// 
	void setBBox3D(BBox3Df bbox) {
		std::unique_lock<std::mutex> lock(m_mutex);
		m_bbox = bbox;
	}

	/// 
	/// @brief Get 3D bounding box of map
	/// @return the name of map
	/// 
	BBox3Df getBBox3D() {
		std::unique_lock<std::mutex> lock(m_mutex);
		return m_bbox;
	}
	
private:
	boost::uuids::uuid							m_uuid;
	std::string									m_name;			
	std::string									m_author;			
	std::chrono::system_clock::time_point		m_createdTime;
	std::chrono::system_clock::time_point		m_lastUpdatedTime;
	BBox3Df										m_bbox;
	std::mutex									m_mutex;
};

}
}

#endif //SOLAR_DESCRIPTORMATCH_H
